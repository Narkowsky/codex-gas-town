#!/bin/bash
# Block PRs by preventing pushes to arbitrary feature branches.
# Gas Town agents push to main (crew) or polecat/* branches (polecats).
# PRs are for external contributors only.
#
# Also enforces integration branch landing guardrails: pushes to the default
# branch that introduce integration branch content are blocked unless
# GT_INTEGRATION_LAND=1 is set (only gt mq integration land sets this).

# Detect the rig's default branch dynamically.
# Fallback chain matches Go implementation (git.RemoteDefaultBranch):
# 1. origin/HEAD symref
# 2. origin/master (if it exists)
# 3. origin/main (final fallback)
default_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's#refs/remotes/origin/##')
if [[ -z "$default_branch" ]]; then
  if git rev-parse --verify origin/master &>/dev/null; then
    default_branch=master
  else
    default_branch=main
  fi
fi

# GitHub hard-rejects blobs larger than 100MB.
MAX_GITHUB_BLOB_SIZE=$((100 * 1024 * 1024))
# npm wrapper script should remain a tiny Node shim, not a native binary.
MAX_GT_JS_SHIM_SIZE=$((512 * 1024))
NULL_SHA="0000000000000000000000000000000000000000"

check_oversized_blobs() {
  local range=$1
  local oversized
  oversized=$(
    git rev-list --objects "$range" \
      | git cat-file --batch-check='%(objectname) %(objecttype) %(objectsize) %(rest)' \
      | awk -v limit="$MAX_GITHUB_BLOB_SIZE" '$2=="blob" && $3>limit {print $4 "\t" $3}'
  )
  if [[ -n "$oversized" ]]; then
    echo "ERROR: Push contains blob(s) larger than 100MB (GitHub hard limit)."
    echo ""
    echo "$oversized" | while IFS=$'\t' read -r path size; do
      [[ -z "$path" ]] && path="<unknown>"
      echo "  - $path (${size} bytes)"
    done
    echo ""
    echo "Fix: remove or replace oversized files before pushing."
    return 1
  fi
  return 0
}

validate_gt_js_shim() {
  local tip_sha=$1

  # If the shim does not exist at tip, nothing to validate.
  if ! git cat-file -e "${tip_sha}:npm-package/bin/gt.js" 2>/dev/null; then
    return 0
  fi

  local size
  size=$(git cat-file -s "${tip_sha}:npm-package/bin/gt.js" 2>/dev/null || echo 0)
  if [[ "$size" =~ ^[0-9]+$ ]] && (( size > MAX_GT_JS_SHIM_SIZE )); then
    echo "ERROR: npm-package/bin/gt.js is unexpectedly large (${size} bytes)."
    echo "It should be a small Node shim, not a compiled binary."
    return 1
  fi

  local first_line
  first_line=$(git show "${tip_sha}:npm-package/bin/gt.js" 2>/dev/null | head -n 1)
  if [[ "$first_line" != "#!/usr/bin/env node" ]]; then
    echo "ERROR: npm-package/bin/gt.js does not look like the expected Node shim."
    echo "Expected first line: #!/usr/bin/env node"
    return 1
  fi

  return 0
}

# Allowed patterns:
#   <default_branch>, beads-sync  - Direct work branches
#   polecat/*                     - Polecat working branches (Refinery merges these)
#   integration/*                 - Integration branches (created by gt mq integration)

while read local_ref local_sha remote_ref remote_sha; do
  # Skip tags - they're allowed for releases
  if [[ "$remote_ref" == refs/tags/* ]]; then
    continue
  fi

  branch="${remote_ref#refs/heads/}"

  case "$branch" in
    "${default_branch}"|beads-sync|polecat/*|integration/*)
      # Allowed branches
      ;;
    *)
      # Allow feature branches when contributing to upstream (fork workflow).
      # If an 'upstream' remote exists, this is a contribution setup where
      # feature branches are needed for PRs. See: #848
      if ! git remote get-url upstream &>/dev/null; then
        echo "ERROR: Invalid branch for Gas Town agents."
        echo ""
        echo "Blocked push to: $branch"
        echo ""
        echo "Allowed branches:"
        echo "  ${default_branch}        - Crew workers push here directly"
        echo "  polecat/*   - Polecat working branches"
        echo "  integration/* - Integration branches"
        echo "  beads-sync  - Beads synchronization"
        echo ""
        echo "Do NOT create PRs. Push to main or let Refinery merge polecat work."
        exit 1
      fi
      ;;
  esac

  # Skip branch deletions.
  if [[ "$local_sha" == "$NULL_SHA" ]]; then
    continue
  fi

  # Range of commits being introduced by this ref update.
  range="$local_sha"
  if [[ "$remote_sha" != "$NULL_SHA" ]]; then
    range="${remote_sha}..${local_sha}"
  fi

  # Guard 1: block any blob >100MB before GitHub rejects the push.
  if ! check_oversized_blobs "$range"; then
    exit 1
  fi

  # Guard 2: keep npm wrapper as a text shim (prevent accidental binary copy).
  if ! validate_gt_js_shim "$local_sha"; then
    exit 1
  fi

  # Integration branch landing guardrail: when pushing to the default branch,
  # check if any integration branch tip is newly reachable from this push.
  # This catches merges (--no-ff, --ff-only, default) and rebases.
  # Only cherry-picks (new SHAs) are not detected â€” Layer 1 covers those.
  if [[ "$branch" == "$default_branch" ]] && [[ "$GT_INTEGRATION_LAND" != "1" ]]; then
    # Skip for deletions or initial pushes
    if [[ "$remote_sha" == "0000000000000000000000000000000000000000" ]] || \
       [[ "$local_sha" == "0000000000000000000000000000000000000000" ]]; then
      continue
    fi
    # Check if any integration branch tip is newly reachable from this push.
    # Use ls-remote instead of for-each-ref to avoid false positives from stale
    # local tracking refs that may linger after branch deletion.
    # Fail closed: if ls-remote fails (network error), block the push rather than
    # silently allowing unverified integration branch content through.
    integration_refs=$(git ls-remote --quiet origin "refs/heads/integration/*" 2>&1) || {
      echo "WARNING: Cannot verify integration branches (remote unreachable)."
      echo "Push to $default_branch blocked. Retry when network is available,"
      echo "or set GT_INTEGRATION_LAND=1 if this is an intentional land operation."
      exit 1
    }
    for ref in $(echo "$integration_refs" | awk '{print $1}'); do
      if git merge-base --is-ancestor "$ref" "$local_sha" && \
         ! git merge-base --is-ancestor "$ref" "$remote_sha"; then
        echo "BLOCKED: Push to $default_branch introduces integration branch content."
        echo ""
        echo "Integration branches must be landed via: gt mq integration land <epic-id>"
        echo ""
        echo "This guardrail prevents accidental landing of integration branches."
        echo "The gt mq integration land command sets GT_INTEGRATION_LAND=1 to bypass this check."
        exit 1
      fi
    done
  fi
done

exit 0
